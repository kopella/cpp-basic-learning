# 函数

## 函数声明

函数声明负责指定函数的名字、返回值的类型以及调用该函数所需的参数数量和类型。

函数声明中可以包含参数的名字， 这样有助于读者理解函数的含义， 但是编译器会直接忽略参数的名字。

函数的类型包括返回类型和参数的类型， 对于类成员函数来说，类的名字也是函数类型的一部分。
> 示例:
>
> ```cpp
> char& String::operator[](int);
> ```

### 函数定义

如果函数会在程序中调用，那么它必须再某处定义。函数定义是特殊的函数声明，它给出了函数体的内容。

函数定义以及全部声明必须对应同一类型。不过为了与 C 语言兼容， 一般会自动忽略参数类型的顶层 `const`。

函数的参数名字不属于函数类型的一部分，不同的声明语句中参数的名字无须保持一致。

### 返回值

绝大部分函数声明都包含函数的返回类型。传统上，返回类型位于函数声明语句一开始的地方，然而，我们也可以在函数声明中把返回类型写在参数列表之后。
> 示例:
>
> ```cpp
> string to_string(int a);
> auto to_string(int a) -> string;
> ```
>
> 后置返回类型的必要性源于函数模板声明， 因为其返回类型是依赖于参数的。虽然世界上任何函数都可以是用后置返回类型。

如果函数不返回任何值，则其“返回类型”是 `void`。若没有被声明为 `void`，则函数必须返回某个值。

### `inline` 函数

`inline` 限定符会告诉编译器，它应该尝试为被修饰的函数调用生产内联代码，而非先为函数构建代码再哦通过常规的调用机制调用它。

但是内联函数可能会面临许多复杂的情况，例如内联函数之间的互相递归调用、单个内联的递归函数以及函数与输入无关，等等。这时候编译器无法包扎每一次调用都真的是内联的。

### `constexpr` 函数

通过将函数指定为 `constexpr`，可以告诉编译器这个函数“如果给定了常量表达式作为实参，则该函数应该能用在常量表达式中”。
> 示例：
>
> ```cpp
> constexpr int fac(int n){
>   return (n>1)?n*fac(n-1):1
> }
>
> int f5 = fac(5); // 可能在编译时求值。
> int fn = fac(n); // 运行时求值。
> constexpr int f6 = fac(6); // 必须在编译时求值。
>
> char a[fac(4)]; // 数组的尺寸必须为常量，而 fac() 是 `constexpr`。
> ```

`constexpr` 函数必须有返回值，没有循环，也没有局部变量，且不能有副作用，但允许递归和条件表达式。

## 参数传递

当程序调用一个函数时，会为该函数的形参申请内存空间，并用实参初始化对应的形参。参数传递的语义与拷贝初始化的语义一致。也就是说，除非形参是引用，其他情况下传入函数的是实参的一个副本。

### 引用参数

传递引用相比传值在面对大对象时会更加高效，但同时应该避免修改引用类型的实参，因为这样可能会让代码的读者感到困扰。最好的方法时将该引用类型的参数声明为 const，以表明这里使用引用只是处于效率上的考虑。

引用传递的准确描述应该是左值引用传递，除了析构函数与重新赋值函数，函数本身并不接受一个右值引用作为它的参数。

### 数组参数

数组作为函数的参数时，实际传入的是指向该数组首元素的指针。即，作为参数被传入函数时，类型 `T[]` 会被转化为 `T*`，这意味着如果对数组参数的元素赋值，则会改变数组元素的实际值。也就是说，数组类型的参数与指针类型的参数是等价的。
> 示例：
>
> ```cpp
> void odd(int* p);
> void odd(int a[]);
> void odd(int buf[1020]);
> ```
>
> 这三个声明是等价的，它们声明的是同一个函数。

### 列表参数

一个由 `{}` 限定的列表可以作为下述形参的实参：

- 类型 `std::initializer_list<T>`，其中列表的值能隐式地转换成 T
- 能用列表中的值初始化的类型。
- T 类型数组的引用，其中列表的值能隐式地转换成 T。

### 数量未定的参数

对于某些函数来说，很难明确指定调用时期望的参数数量和类型，要实现这样的借口，有以下选择：

- 使用可变模板：它允许我们以类型安全的方式处理任意类型、任意数量的参数。
- 使用 `initializer_list` 作为参数类型：它允许我们以类型安全的方式处理任意类型、任意数量的参数。
- 用省略号结束参数列表，表示可能有更多参数。
