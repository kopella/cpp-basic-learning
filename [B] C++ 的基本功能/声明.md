# 声明

## 声明的结构

C++ 声明语句在不简化的情况下能够分为 5 个部分:

- 可选的前置修饰符（如 `static` 和 `virtual`）
- 基本类型的说明符（如 `vector<double>` 和 `const int`）
- 可选的声明符，可包含一个名字（如 `p[7]` 和 `*(*)[]`）
- 可选的后缀函数修饰符（如 `const` 和 `noexcept`）
- 可选的初始化器或函数体（如 `{7，5，3}` 和 `{return x;}`）

前置修饰符的作用是指定声明对象的某些非类型属性。

声明符由一个名字和一些可选的声明运算符组成。
> 常用的声明运算符有:
> ||||
> |:---:|:---:|:---:|
> |前缀|`*`|指针|
> |前缀|`*const`|const 指针|
> |前缀|`*volatile`|volatile 指针|
> |前缀|`&`|左值引用|
> |前缀|`&&`|右值引用|
> |前缀|`auto`|使用后置转化类型的函数|
> |后缀|`[]`|数组|
> |后缀|`()`|函数|
> |后缀|`->`|从函数返回|
>
> 后缀声明符的优先级比前缀声明符更高，也可以通过 `()` 手动调整优先级。
> 示例:
>
> ```cpp
> char *kings[];
> // 声明符中的 `*kings[]` 意味着标识符 kings 首先是个数组，数组中容纳着指针，指针指向的对象为 `char` 类型。
> 
> char (*kings)[];
> // 声明符中的 `(*kings)[]` 意味着标识符 kings 首先是个指针，这个指针指向一个数组，这个数组容纳 `char` 对象。
>
> int (*(*foo)(double))[3] = nullptr;
> // 声明符中的 `(*(*foo)(double))[3]` 意味着标识符 foo 首先是一个指针，这个指针指向一个接受值为 `double` 的函数，这个函数的返回类型为一个指向数组的指针，这个数组容纳了 3 个 `int` 元素。
> // 初始化器 `= nullptr` 提供了指针 foo 的初始值。

C++ 允许在同一条声明语句中声明多个名字，但需要注意的是，声明运算符值作用于紧邻的一个名字，对于其他名字是无效的。
> 示例:
>
> ```cpp
> int *p，n; // 等价于 `int *p; int n`。
> int v[10]，*pv // 等价于 `int v[10]; int *pv;`。
> ```

C++ 要求名字包含若干字母和数字，其中第一个字符必须是字母，同时把下划线 _ 也视作字母。
> 关于命名方法，最好遵循某些约定俗成的命名风格，并且坚持下去。

## 作用域

声明语句为作用域引入一个新名字，换句话说，某个名字只能在程序文本的某个特定区域使用。

作用域包括了:

- 局部作用域
- 类作用域
- 名字空间作用域
- 全局作用域
- 语句作用域
- 函数作用域

在块内声明的名字能够隐藏外层块及全局作用域中的同名声明，可以使用域解析运算符访问被隐藏了的全局名字，无法使用被隐藏的局部名字。
> 示例:
>
> ```cpp
> int x = 1;
> void f() {
>   int x = 1; // 全局变量 x 被隐藏了。
>   ::x = 2; // 为全局变量 x 赋值。
>   x = 2; // 为局部变量 x 赋值。
> }

## 初始化

C++ 的初始化器有四种形式:

```cpp
X a1 {v}; // 列表初始化器，可以防止窄化转化，在 C++11 后可用。
X a2 = {v};
X a3 = v; 
X a4(v); // 调用构造函数。
```

一般而言，使用指定类型声明时最好使用 `{}` 的初始化器语法，使用 `auto` 声明时最好使用 `=` 语法。

## 类型推断

C++ 语言提供了两种从表达式推断数据类型的机制:

- `auto` 根据对象的初始化器判断对象的数据类型。
- `decltype(expr)` 推断表达式的类型。

> 关于 `{}` 列表与 `auto` 的选择:
> 使用初始化列表是为了减少意料之外的类型转换，而当我们使用 `auto` 关键字时，只涉及一种类型，所以此时使用 `=` 是安全的。
>
> 但需要注意的是，`auto` 与 `{}` 最好不要同时使用，除非我们期望得到某种列表类型。
>
> 示例:
>
> ```cpp
> auto v1 = 12345; // v1: int
> auto v2 = 'c'; // v2: char
> auto x1 {1}; // x1: initializer_list<int>
> ```

`decltype()` 修饰符在泛型编程中很有用，很多时候如果即想要推断得到类型，又不想额外定义一个初始化的变量时，就可以使用 `decltype()`。
