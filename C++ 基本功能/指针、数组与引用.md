# 指针、数组与引用

## 指针

对于一个类型 T 来说，指向 T 的指针(T*)作为一个类型表示的是存放 T 类型对象地址的变量。

对于指针的一个基本操作是解引用，即引用指针所指的对象。 这个操作也被称为间接取值。
> 示例:
>
> ```cpp
> char c = 'a';
> char *p = &c;
> char c2 = *p;
> ```

### `void*`

除了函数指针与指向类成员的指针，指向其他任意类型的对象的指针都能被赋值给一个 `void*` 类型的变量。 但要想使用 `void*` 需要首先把它显示地转化为某一特定类型的指针。

### `nullptr`

`nullptr` 是一个字面值常量，表示空指针，即不指向任何对象的指针。

使用 `nullptr` 有许多好处，它的可读性更强，还能避免使用一组重载函数时语义混淆。

## 数组

对于一个类型 T 来说，`T[size]` 表示的含义是包含 size 个 T 类型元素的数组，元素的索引值为 0 到 size-1。

可以使用下标运算符或指针访问数组中的元素。
> 除了遍历以外,还可以使用列表初始化出是一个数组。
> 示例:
>
> ```cpp
> int v[] = {1, 2, 3, 4};
> ```
>
> 需要注意的是，C++ 没有为数组提供内置的拷贝和赋值操作，因此不允许一个数组初始化另一个数组。

### 多维数组

多维数组是指数组的数组。
> 示例:
>
> ```cpp
> int ma[3][5];
> ```

## 引用

引用实际上是对象的别名，最重要的用途是作为函数的实参或返回值，此外，也被用于重载函数符。

一般区分为三种引用方式:

- 左值引用: 引用那些希望改变值得对象。
- const 引用: 引用那些不希望改变值的对象，一般是左值引用。
- 右值引用: 引用那些使用后就无需保留了的对象。

### 左值引用

在声明语句中，符号 `X&` 的意思就是 X 的引用，常用于表示左值的引用。
> 示例:
>
> ```cpp
> int var = 1;
> int& r {var}; // 用列表初始化的方式给引用 r 初始化。
> ```

由于不存在空引用，必须确保引用对应了某个对象，声明引用时就必须要初始化引用。
> 需要注意的是，初始化引用和给引用赋值时完全不同的操作。
> 示例:
>
> ```cpp
> int var = 1;
> int& r = var; // 用 `=` 初始化的方式给引用 r 初始化。
> r = 2; // 将 r 的值赋值为 2。
> ```

### 右值引用

右值引用可以绑定到右值，不能绑定到左值。 在声明语句中，符号 `&&` 表示右值引用，一般不使用 `const` 右值引用，因为右值引用的大多数用法都是建立在能够修改所引对象的基础上的。

通过事先判断引用所引对象是否是临时对象，如果是的话，就能用比较廉价的移动操作替代昂贵的拷贝操作了。

当右值引用被用作初始化器或者赋值操作的右侧运算对象时，程序将使用移动操作。
> 示例:
>
> ```cpp
> template<class T>
> void swap(T& a, T& b) {
>   T tmp {static_cast<T&&>(a)};
>   a = static_cast<T&&>(b);
>   b = static_cast<T&&>(tmp);
> }
> ```
>
> 在这段代码中，`static_cast<T&&>(x)` 的结果是 `T&&` 类型的右值引用，引用对象是 x，若类型 T 含有移动构造函数或移动赋值运算符时，程序就会使用移动操作。
>
> 在程序中使用 `static_cast<X&&>(x)` 显得稍有一点繁琐，可以使用标准库中等价的 `move(x)` 代替。
>
> 需要注意的是，无论是 `static_cast<X&&>(x)` 还是 `move(x)` 它们都不执行移动操作，只是给 x 创建了一个右值引用。

### 引用的引用

如果用引用指向某种类型的引用，得到的还是该类型的引用，而不是什么特殊的引用类型。

而且，用该方法得到的引用类型永远是左值引用优先。
> 示例:
>
> ```cpp
> using rr_i = int&&;
> using lr_i = int&;
> using rr_rr_i = rr_i&&; // 实际类型为 `int&&`。
> using lr_rr_i = rr_i&; // 实际类型为 `int&`。
> using rr_lr_i = lr_i&&; // 实际类型为 `int&`。
> using lr_lr_i = lr_i&; // 实际类型为 `int&`。
> ```

## 指针与数组

在 C++ 中，指针与数组密切相关。 数组名可以看成是指向数组首元素的指针。
> 令指针指向数组的最后一个元素的下一个位置，即尾后位置是有效的，这对于很多算法都非常重要，但由于该指针并没有指向数组中的任何一个元素，因此不能对它进行读写操作。

可以通过指向数组的指针加上一个索引值访问数组元素，也可以通过直接指向数组元素的指针进行访问，这两种版本基本上是等同的。
> 原因是内置数组的取下标运算实际上就是通过组合指针的 `+` 与 `*` 两种运算得到的。 对于内置数组 a 和数组范围内的整数 j，有下式成立:
>
> `a[j] == *[&a[0]+j] == *(a+j) == *(j+a) == j[a]`

把 `+`，`-`，`++`，`--` 等算数运算符运用在指针上得到的结果是依赖于指针所指对象的数据类型的，对于指向 T 类型的指针 p 而言，`p+1` 对应的整数值比 `p` 对应的整数值大了 `sizeof(T)`。
> 这也是可以指针自增得到的是指向数组下一个元素的指针的原因。
>
> 因此，指针间的减法运算只有在参与运算的两个指针指向的是同一个数组的元素时才有效。 计算指针 p 和指针 q 的差值 `p-q` 时，所得结果是序列 `[p:q)` 中的元素数量。
>
> 通常而言，没有必要使用复杂的指针运算。

由于数组的元素数量并不一定能与数组本身储存在一起，所以数组不具有自解释性，如果某个数组不像 C 风格字符串那样具有明确的终结符时，那就必须以某种方式提供元素的数量。

## 指针与引用

指针与引用是两种无需拷贝就能在别处使用对象的机制，各有各的又是与不足。

- 如果需要更换所指的对象，那应该使用指针; 如果让某个名字永远对应同一个对象，则应该使用应用。
- 如果想要自定义运算符，使之用于指向对象的某物，应该使用引用。
- 如果想让一个集合中的元素指向对象，应该使用指针。
- 如果需要表示 "值空缺"，则应该使用指针。
